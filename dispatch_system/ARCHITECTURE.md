# 调度指挥系统架构设计文档 V2.0

## 架构演进说明

从OpenManus的复杂Agent框架跳脱，设计**轻量级状态驱动架构**，专注调度场景的核心需求：
- **状态实时可见**：每一步的状态变更可实时获取
- **可扩展分层**：清晰的层次结构，支持未来功能扩展
- **零侵入设计**：不依赖复杂框架，保持代码简洁

## 核心架构决策

### 1. 状态记录员Agent的存废分析

#### ❌ 不建议独立StatusRecorder Agent

**坏处：**
- **过度设计**：调度场景简单，不需要复杂Agent通信
- **性能开销**：Agent间通信增加延迟，不符合调度快速响应需求
- **复杂化**：引入不必要的抽象，违背"轻量级"原则

**好处：**
- **职责单一**：符合SRP原则
- **可扩展**：未来可独立部署为状态服务

#### ✅ 推荐方案：状态管理模块

采用**模块化的状态管理器**替代独立Agent：
- **轻量级**：普通Python类，无Agent框架开销
- **可持久化**：支持数据库/文件持久化
- **事件驱动**：支持实时状态推送
- **可升级**：未来可轻松升级为独立服务

### 2. 分层架构设计

```
dispatch_system/
├── core/                    # 核心业务层
│   ├── __init__.py
│   ├── state_manager.py    # 状态管理器（替代StatusRecorder Agent）
│   ├── planner.py          # 规划器（简化版，非Agent）
│   ├── executor.py         # 执行器（简化版，非Agent）
│   └── models.py           # 数据模型
├── persistence/            # 持久化层
│   ├── __init__.py
│   ├── state_store.py      # 状态存储抽象
│   ├── file_store.py       # 文件存储实现
│   └── db_store.py         # 数据库存储实现（预留）
├── api/                    # 接口层
│   ├── __init__.py
│   ├── websocket_server.py # WebSocket状态推送
│   └── rest_api.py         # REST API（预留）
├── cli/                    # 命令行接口
│   ├── __init__.py
│   └── interface.py        # 交互式命令行
├── tools/                  # 工具集成
│   ├── __init__.py
│   └── mcp_client.py       # MCP工具调用
└── tests/                  # 测试
    ├── __init__.py
    └── test_core.py
```

### 3. 状态持久化设计

#### 存储策略
- **实时存储**：每次状态变更立即持久化
- **分层存储**：热数据内存+冷数据文件/数据库
- **可追溯**：支持完整执行历史的回放

#### 数据模型
```python
class ExecutionRecord:
    """执行记录"""
    execution_id: str           # 执行批次ID
    emergency_data: Dict        # 警情数据快照
    command: str               # 调度指令
    start_time: datetime       # 开始时间
    end_time: Optional[datetime] # 结束时间
    overall_status: str        # 整体状态
    steps: List[StepRecord]    # 步骤详情

class StepRecord:
    """步骤记录"""
    step_id: str
    name: str
    status: StepStatus
    start_time: datetime
    end_time: Optional[datetime]
    parameters: Dict
    result: Optional[str]
    error: Optional[str]
    retry_count: int
```

#### 存储格式
- **JSON文件**：便于调试和版本控制
- **SQLite**：轻量级关系型存储
- **Redis**：高性能缓存（可选）

### 4. Plan的动态管理设计

#### 挂起/恢复机制
```python
class PlanManager:
    """计划管理器"""
    
    def pause_plan(self, execution_id: str) -> bool:
        """挂起当前执行计划"""
        pass
    
    def resume_plan(self, execution_id: str) -> bool:
        """恢复被挂起的执行计划"""
        pass
    
    def modify_plan(self, execution_id: str, new_steps: List[ExecutionStep]) -> bool:
        """修改执行中的计划"""
        pass
    
    def cancel_plan(self, execution_id: str) -> bool:
        """取消执行计划"""
        pass
```

#### 用户中断处理流程
1. **中断检测**：监听用户输入，检测中断指令
2. **优雅停止**：等待当前步骤完成，标记后续步骤为取消
3. **状态保存**：持久化当前状态，支持后续恢复
4. **用户确认**：询问用户是暂停、修改还是重新开始

#### 场景示例
```
用户场景：
1. 输入"handle_all"开始一键处置
2. 执行到step2(查看值班人员)时，用户发现地址有误
3. 用户输入"pause"暂停执行
4. 用户修改警情地址
5. 用户输入"resume"继续执行，或"restart"重新开始
```

### 5. 实时状态推送设计

#### 事件流架构
```python
class EventBus:
    """事件总线"""
    
    def subscribe(self, event_type: str, callback: Callable):
        """订阅事件"""
        pass
    
    def publish(self, event: Event):
        """发布事件"""
        pass

class WebSocketHandler:
    """WebSocket状态推送"""
    
    async def handle_client(self, websocket, path):
        """处理客户端连接"""
        pass
```

#### 状态同步策略
- **增量更新**：只推送变更的状态
- **心跳机制**：保持连接活跃
- **断线重连**：自动恢复状态同步
- **历史回放**：支持查看历史状态

### 6. 扩展性设计

#### 水平扩展
- **无状态设计**：状态存储独立，支持多实例部署
- **负载均衡**：支持基于执行ID的负载分发
- **故障转移**：支持执行状态的快速恢复

#### 功能扩展
- **插件系统**：支持自定义工具插件
- **规则引擎**：支持复杂的处置规则
- **机器学习**：基于历史数据优化处置流程

#### 集成扩展
- **第三方系统**：支持与其他指挥系统集成
- **移动端**：支持移动设备实时查看状态
- **大屏展示**：支持调度大厅大屏展示

## 技术选型决策

### 存储技术栈
- **首选**：SQLite + JSON文件（简单场景）
- **升级**：PostgreSQL（复杂场景）
- **缓存**：Redis（高性能需求）

### 通信技术栈
- **实时推送**：WebSocket + asyncio
- **API接口**：FastAPI（预留）
- **消息队列**：Redis Pub/Sub（可选）

### 部署架构
- **单机版**：一体化部署，适合小场景
- **微服务版**：状态服务独立，支持集群
- **混合云**：本地+云端混合部署

---

# 附录B：系统简化说明

## 架构演进

### 已移除的冗余组件

1. **business_guidance目录** - 业务指导文件
   - 原因：调度场景使用固定业务逻辑，无需动态配置
   - 替代：硬编码在核心逻辑中的标准三步流程

2. **tools目录配置** 
   - 原因：工具由MCP server直接提供，无需本地定义
   - 替代：通过MCP协议直接调用远程工具

3. **复杂配置系统**
   - 原因：调度场景需求简单，无需复杂配置
   - 替代：简单参数映射和固定流程

## 最终架构特点

### 极简设计
- **3个核心工具**：getPOI、showQw、callPhone
- **2种执行模式**：单步执行、一键处置
- **1个核心流程**：信息收集→资源查看→人员联系

### 即插即用
- 依赖MCP server提供工具能力
- 零配置启动
- 命令行直接交互

## 数据流设计

```
用户输入 → 规划器生成步骤 → 状态管理器初始化 → 执行器逐个执行
                    ↓
            状态变更事件 → 持久化存储 → WebSocket推送 → 前端展示
                    ↓
            用户中断 → 状态挂起 → 用户决策 → 恢复/修改/取消
```

## 容灾设计

### 故障恢复
- **执行状态恢复**：支持断电重启后的状态恢复
- **数据一致性**：保证状态数据的完整性和一致性
- **失败通知**：关键故障的及时通知机制

### 备份策略
- **实时备份**：关键状态变更的实时备份
- **定期备份**：完整数据的定期备份
- **异地备份**：重要数据的异地存储

## 监控与运维

### 监控指标
- **执行成功率**：步骤执行的成功/失败统计
- **响应时间**：各步骤的平均执行时间
- **并发量**：同时处理的执行批次数量
- **资源使用**：CPU、内存、网络等资源使用

### 运维接口
- **健康检查**：系统健康状态查询
- **性能监控**：实时性能数据获取
- **故障诊断**：问题定位和诊断工具

---

# 附录A：核心规范（源自早期设计文档）

## MCP工具清单

### 1. 打开周边监控 (`getPOI`)
- **用途**: 根据案发地点坐标打开周边监控
- **参数**:
  - `x_position`: 案发地点X坐标
  - `y_position`: 案发地点Y坐标  
  - `afdd`: 案发地点地址

### 2. 查看值班人员 (`showQw`)
- **用途**: 根据管辖单位代码查看值班人员信息
- **参数**:
  - `gxdwdm`: 管辖单位代码

### 3. 拨打值班电话 (`callPhone`)
- **用途**: 拨打指定值班人员电话
- **参数**:
  - `phone`: 值班人员电话

## 标准数据结构

### 警情数据JSON格式
```json
{
  "coordinates": {
    "x": "123.456789",
    "y": "39.123456"
  },
  "address": "北京市朝阳区xxx路xxx号",
  "unit_code": "110105",
  "emergency_type": "重大警情",
  "description": "简要案情描述"
}
```

### 状态输出格式规范
```
[调度系统] 正在执行: 打开周边监控
[调度系统] 坐标: 123.456789, 39.123456
[调度系统] 执行成功: 已打开北京市朝阳区xxx路xxx号的周边监控
```

### 失败重试策略
- **最大重试次数**: 3次
- **重试间隔**: 固定1秒（调度场景需要快速响应）
- **错误输出格式**:
```
[调度系统] 执行失败: 打开周边监控
[调度系统] 错误原因: 网络连接超时
[调度系统] 已重试3次，建议检查网络连接
```